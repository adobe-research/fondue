<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Fondue documentation</title>
<style>

@import url(style.css);

table.api tt {
	white-space: nowrap;
}

</style>
</head>

<h1>Fondue documentation</h1>

<div id="toc">
<ol>
<li><a href="#section-whats-fondue">What's fondue?</a>
<li><a href="#section-how-to-trace">How to trace some code</a>
	<ol>
	<li><a href="#section-example-01">Example: a script that inspects itself</a>
	<li><a href="#section-example-02">Example: a script that inspects another script</a>
	</ol>
<li><a href="#section-how-to-access">How to access the data (Fondue's API)</a>
	<ol>
	<li><a href="#section-api">API Reference</a>
	</ol>
<li><a href="#section-fancy">Getting fancy (tracing whole programs, whole web sites, etc)</a>
</ol>
</div>

<h2 id="section-whats-fondue">What's fondue?</h2>

<p>Fondue is a real-time program tracing library for JavaScript. You use it if you want to:

<ul>
<li>Visualize the function calls in a program
<li>Get a graph of all the files and functions that are defined in a program
</ul>

<p>Get the code with <tt class="command">git clone https://github.com/adobe-research/fondue.git</tt> or use it in your Node.js project with <tt class="command">npm install fondue</tt>.

<h2 id="section-how-to-trace">How to trace some code</h2>

<p>Call <tt class="code">require('fondue').instrument(src, options)</tt>. You pass it the JavaScript code you want to trace as a string, and it returns the same code, but modified so that if you run it, it will store trace data in a global object called <tt>__tracer</tt>.

<h3 id="section-example-01">Example: a script that inspects itself</h3>

<p>Fondue comes with a script <tt>bin/fondue</tt> that calls <tt class="code">instrument(src, { path: ... })</tt> for you automatically. Try saving the following code as <tt>example01.js</tt>:

<pre class="code">// example01.js

var nodesHandle = __tracer.trackNodes();
__tracer.newNodes(nodesHandle).forEach(printNode);

function printNode(node) {
	if (node.type === 'function') {
		console.log('found a function: ' + node.name + ' at ' + node.path + ':' + node.start.line + ' with id ' + node.id);
	}
}</pre>

<p>Then execute the following commands:

<ol>
<li><tt class="command">./fondue/bin/fondue example01.js > example01.fondue.js</tt>
<li><tt class="command">node example01.fondue.js</tt>
</ol>

<p>It should print out something like this:

<pre class="output">found a function: [log] at [built-in]:0 with id log
found a function: printNode at /Users/tom/src/example01.js:6 with id /Users/tom/src/example01.js-function-6-0-10-1</pre>

<p>(<tt>log</tt> is a special function representing <tt>console.log</tt>. You can ignore it in your scripts if you want.)

<p>If you add more functions to <tt>example01.js</tt> and re-run the commands, you should see that it prints out all the functions you add.

<h3 id="section-example-02">Example: a script that inspects another script</h3>

<p>You can find basically the same example in <a href="playground.html">the Fondue playground</a>. Just hit "Run". You might find it easier to experiment there than on the command-line.

<h2 id="section-how-to-access">How to access the data (Fondue's API)</h2>

<p><tt>__tracer</tt> uses a polling data model. As you saw in the example, to get all nodes, first you call <tt class="code">trackNodes()</tt> to get a <tt class="code">handle</tt> object, then you call <tt class="code">newNodes(handle)</tt> to get all the nodes that have been instrumented since the last call to <tt class="code">newNodes</tt>.

<p>As another example, <tt class="code">trackHits()</tt> gives you a handle for tracking the hit counts of all functions. <tt class="code">hitCountDeltas(handle)</tt> gives you an object containing the counts of all function calls that occurred since the last call to <tt class="code">hitCountDeltas(handle)</tt> for that handle:

<pre class="code">var hitsHandle = __tracer.trackHits();
var hits1 = __tracer.hitCountDeltas(hitsHandle); // { 'func-id-1' : 1, 'func-id-2' : 3 }
var hits2 = __tracer.hitCountDeltas(hitsHandle); // {}
var hits3 = __tracer.hitCountDeltas(hitsHandle); // {}
var hits4 = __tracer.hitCountDeltas(hitsHandle); // { 'func-id-2' : 1 }
var hits5 = __tracer.hitCountDeltas(hitsHandle); // {}
// ...
</pre>

<h3 id="section-api">API Reference</h3>

<p>I apologize for inconsistencies. The only consumer of this API until recently was my own project, <a href="https://github.com/adobe-research/theseus">Theseus</a>.

<h4>Fondue's API</h4>

<table class="api outlined">
	<tr>
		<th>
			<tt class="code">require('fondue').instrument(src, options)</tt><br />
			<tt class="code">fondue.instrument(src, options)</tt>
		</th>
		<td>
			<p>Use the first version in Node.js (after <tt>npm install fondue</tt>) and the second version if you include <tt><a href="https://github.com/adobe-research/fondue/blob/master/fondue.browser.js">fondue.browser.js</a></tt> on a web page, which creates a global <tt>fondue</tt> object.

			<p>These functions take JavaScript source code in the <tt>src</tt> argument and return a string containing an instrumented version of that source code.

			<p><tt>options</tt> is an object (or null) with any the following keys:

			<table class="outlined">
				<tr>
					<th>Key</th>
					<th>Default value</th>
					<th>Description</th>
				</tr>
				<tr>
					<th><tt>path</tt></th>
					<th><tt>"&lt;anonymous&gt;"</tt></th>
					<td>The path of the source code being instrumented. It doesn't load the code from that page, only embeds that information as meta-data, so it can be whatever you want.</td>
				</tr>
				<tr>
					<th><tt>include_prefix</tt></th>
					<th><tt>true</tt></th>
					<td>Whether to include the source code underlying the <tt>__tracer</tt> object. It's okay for this code to be included multiple times, so always leaving it on is okay. It's just kind of big.</td>
				</tr>
				<tr>
					<th><tt>tracer_name</tt></th>
					<th><tt>__tracer</tt></th>
					<td>The name to use for the global object containing the trace information.</td>
				</tr>
				<tr>
					<th><tt>nodejs</tt></th>
					<th><tt>false</tt></th>
					<td>If <tt>src</tt> will be executed in Node.js (not the browser), then set this to true to enable some Node.js-specific functionality.</td>
				</tr>
				<tr>
					<th><tt>maxInvocationsPerTick</tt></th>
					<th><tt>4096</tt></th>
					<td>When more than this many trace points (nodes) are executed in a single tick of the JavaScript VM, fondue will stop storing trace information until the next tick. This prevents intense calculation from filling all your RAM.</td>
				</tr>
				<tr>
					<th><tt>throw_parse_errors</tt></th>
					<th><tt>false</tt></th>
					<td>Whether to throw parse errors as exceptions, or just print them with <tt>console.error</tt> and attempt to continue. By default, when there's a parse error, the code is just passed through without instrumentation.</td>
				</tr>
			</table>
		</td>
	</tr>
</table>

<h4><tt>__tracer</tt> API</h4>

<p>Fondue-instrumented code creates a global <tt>__tracer</tt> object that you can also access to get information about that code's execution.

<table class="api outlined">
	<tr>
		<th><tt class="code">__tracer.version()</tt></th>
		<td>Returns a string like <tt>"0.6.1"</tt> with the version of Fondue being used.</td>
	</tr>
	<tr>
		<th>
			<tt class="code">handle = __tracer.trackNodes()</tt><br />
			<tt class="code">nodes = __tracer.newNodes(handle)</tt>
		</th>
		<td>
			<p>Get all known trace points in the program (functions, function call sites, etc).

			<table class="outlined">
				<tr>
					<th><tt>id</tt></th>
					<td>Unique string identifier for this node. It currently consists of the path, start, and end locations in the file, separated by dashes, but please don't rely on that.</td>
				</tr>
				<tr>
					<th><tt>type</tt></th>
					<td>The node type as a string. Currently one of <tt>"toplevel"</tt>, <tt>"function"</tt>, or <tt>"callsite"</tt>.</td>
				</tr>
				<tr>
					<th><tt>name</tt></th>
					<td>A pretty name for the node. For named functions, it's the name. ForÂ anonymous functions, fondue tries to make something appropriate like <tt>"(timer handler (200ms))"</tt>.</td>
				</tr>
				<tr>
					<th><tt>path</tt></th>
					<td>Path of the file the node is in, or <tt>"&lt;anonymous&gt;"</tt>.</td>
				</tr>
				<tr>
					<th><tt>start</tt></th>
					<td>Start location in the file, like <tt class="code">{"line": 1, "column": 0}</tt>.</td>
				</tr>
				<tr>
					<th><tt>end</tt></th>
					<td>End location in the file, like <tt class="code">{"line": 7, "column": 1}</tt>.</td>
				</tr>
				<tr>
					<th><tt>params</tt></th>
					<td>
						<p>An array of the function's arguments (present only if <tt>type</tt> is <tt>function</tt>).

						<table class="outlined">
							<tr>
								<th><tt>name</tt></th>
								<td>Name of the argument</td>
							</tr>
							<tr>
								<th><tt>start</tt></th>
								<td>Start location in the file, like <tt class="code">{"line": 1, "column": 0}</tt>.</td>
							</tr>
							<tr>
								<th><tt>end</tt></th>
								<td>End location in the file, like <tt class="code">{"line": 7, "column": 1}</tt>.</td>
							</tr>
						</table>
					</td>
				</tr>
			</table>
		</td>
	</tr>
	<tr>
		<th>
			<tt class="code">handle = __tracer.trackHits()</tt><br />
			<tt class="code">hits = __tracer.hitCountDeltas(handle)</tt>
		</th>
		<td>
			<p>Get a map from node id to the number of times the node was executed since the last call to <tt>hitCountDeltas</tt> with the given <tt>handle</tt>. Only the ids of functions that actually executed will be present. So, if no code has been executed, <tt>hitCountDeltas</tt> will return an empty object.

			<p>Example return value of <tt>hitCountDeltas</tt>: <tt class="code">{ 'func-id-1' : 1, 'func-id-2' : 3 }</tt>.
		</td>
	</tr>
	<tr>
		<th>
			<tt class="code">handle = __tracer.trackExceptions()</tt><br />
			<tt class="code">hits = __tracer.newExceptions(handle)</tt>
		</th>
		<td>
			<p>Like <tt>trackHits</tt> and <tt>hitCountDeltas</tt>, except it only includes counts for nodes that threw an exception. The return value is also slightly different.

			<p>Example return value of <tt>newExceptions</tt>: <tt class="code">{ counts: { 'func-id-1' : 1, 'func-id-2' : 3 }}</tt>.
		</td>
	</tr>
</table>

<p>There are more functions, which I will document soon. <a href="mailto:tom@alltom.com">E-mail me</a> to bug me about it.

<h2 id="section-fancy">Getting fancy (tracing whole programs, whole web sites, etc)</h2>

<table class="outlined">
	<tr>
		<th>Instrumented code runs in</th>
		<th>Visualization code runs in</th>
		<th>Strategy</th>
	</tr>
	<tr>
		<td>Browser</td>
		<td>Browser</td>
		<td><strong>Pre-processing.</strong> Pre-process the code with <tt>bin/fondue</tt> (as in the example above) or with <tt>require('fondue').instrument(src, options)</tt> in Node.js, then execute the output on a web page with a <tt>&lt;script&gt;</tt> tag. That creates a global <tt>__tracer</tt> on which you can call the above methods directly from the same page. The "script that inspects itself" example on this page works this way.</td>
	</tr>
	<tr>
		<td>Node.js</td>
		<td>Node.js</td>
		<td><strong>Pre-processing.</strong> Same as with the Browser/Browser case above. <tt>eval()</tt> code that has been run through the <tt>instrument()</tt> function and check the global <tt>__tracer</tt> object.</td>
	</tr>
	<tr>
		<td>Browser</td>
		<td>Browser</td>
		<td><strong>Dynamic instrumentation.</strong> Process the code with <tt>fondue.instrument(src, options)</tt> on a web page itself after including <tt><a href="https://github.com/adobe-research/fondue/blob/master/fondue.browser.js">fondue.browser.js</a></tt>, the browser build of Fondue. Execute the output with <tt>eval(src)</tt>. That also creates a global <tt>__tracer</tt> on which you can call the above methods directly. <a href="playground.html">The Fondue playground</a> works this way.</td>
	</tr>
	<tr>
		<td>Browser</td>
		<td>Browser</td>
		<td><strong>Node.js middleware.</strong> Drop <a href="https://github.com/alltom/fondue-middleware">fondue-middleware</a> into a Node.js server. When it detects that you're serving a JavaScript file, or an HTML file with embedded <tt>&lt;script&gt;</tt> tags, it will automatically process the scripts with Fondue. When that code executes on the web page, that creates a global <tt>__tracer</tt> object on which you can call the above methods directly.</td>
	</tr>
	<tr>
		<td>Node.js</td>
		<td>Browser</td>
		<td><strong>Remote Node.js instrumentation.</strong> Run the Node.js app with <tt>node-theseus</tt> instead of <tt>node</tt> (first, <tt>npm install -g node-theseus</tt>), which starts a WebSocket server that exposes the <tt>__tracer</tt> object via a simple RPC API. <a href="https://github.com/alltom/node-theseus-d3">Here's an example project that displays information about a running Node.js process with d3</a>.</td>
	</tr>
</table>
