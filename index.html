<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Fondue documentation</title>
<style>

@import url(style.css);

table.api tt {
	white-space: nowrap;
}

</style>
</head>

<h1>Fondue documentation</h1>

<div id="toc">
<ol>
<li><a href="#section-whats-fondue">What's fondue?</a>
<li><a href="#section-how-to-trace">How to trace some code</a>
	<ol>
	<li><a href="#section-example-01">Example: a script that inspects itself</a>
	<li><a href="#section-example-02">Example: a script that inspects another script</a>
	</ol>
<li><a href="#section-how-to-access">How to access the data (Fondue's API)</a>
	<ol>
	<li><a href="#section-api">API Reference</a>
	</ol>
<li><a href="#section-fancy">Getting fancy (tracing whole programs, whole web sites, etc)</a>
</ol>
</div>

<p>You can follow along and play with Fondue in your browser using <a href="playground.html">The Fondue playground</a>.

<h2 id="section-whats-fondue">What's fondue?</h2>

<p>Fondue is a real-time program tracing library for JavaScript. You use it if you want to:

<ul>
<li>Visualize the function calls in a program
<li>Get a graph of all the files and functions that are defined in a program
</ul>

<p>Get the code with <tt class="command">git clone https://github.com/adobe-research/fondue.git</tt> or use it in your Node.js project with <tt class="command">npm install fondue</tt>.

<h2 id="section-how-to-trace">How to trace some code</h2>

<p>Call <tt class="code">require('fondue').instrument(src, options)</tt>. You pass it the JavaScript code you want to trace as a string, and it returns the same code, but modified so that if you run it, it will store trace data in a global object called <tt>__tracer</tt>.

<h3 id="section-example-01">Example: a script that inspects itself</h3>

<p>Fondue comes with a script <tt>bin/fondue</tt> that calls <tt class="code">instrument(src, { path: ... })</tt> for you automatically. Try saving the following code as <tt>example01.js</tt>:

<pre class="code">// example01.js

var nodesHandle = __tracer.trackNodes();
__tracer.newNodes(nodesHandle).forEach(printNode);

function printNode(node) {
	if (node.type === 'function') {
		console.log('found a function: ' + node.name + ' at ' + node.path + ':' + node.start.line + ' with id ' + node.id);
	}
}</pre>

<p>Then execute the following commands:

<ol>
<li><tt class="command">./fondue/bin/fondue example01.js > example01.fondue.js</tt>
<li><tt class="command">node example01.fondue.js</tt>
</ol>

<p>It should print out something like this:

<pre class="output">found a function: [log] at [built-in]:0 with id log
found a function: printNode at /Users/tom/src/example01.js:6 with id /Users/tom/src/example01.js-function-6-0-10-1</pre>

<p>(<tt>log</tt> is a special function representing <tt>console.log</tt>. You can ignore it in your scripts if you want.)

<p>If you add more functions to <tt>example01.js</tt> and re-run the commands, you should see that it prints out all the functions you add.

<h3 id="section-example-02">Example: a script that inspects another script</h3>

<p>You can find basically the same example in <a href="playground.html">the Fondue playground</a>. Just hit "Run". You might find it easier to experiment there than on the command-line.

<h2 id="section-how-to-access">How to access the data (Fondue's API)</h2>

<p><tt>__tracer</tt> uses a polling data model. As you saw in the example, to get all nodes, first you call <tt class="code">trackNodes()</tt> to get a <tt class="code">handle</tt> object, then you call <tt class="code">newNodes(handle)</tt> to get all the nodes that have been instrumented since the last call to <tt class="code">newNodes</tt>.

<p>As another example, <tt class="code">trackHits()</tt> gives you a handle for tracking the hit counts of all functions. <tt class="code">hitCountDeltas(handle)</tt> gives you an object containing the counts of all function calls that occurred since the last call to <tt class="code">hitCountDeltas(handle)</tt> for that handle:

<pre class="code">var hitsHandle = __tracer.trackHits();
var hits1 = __tracer.hitCountDeltas(hitsHandle); // { 'func-id-1' : 1, 'func-id-2' : 3 }
var hits2 = __tracer.hitCountDeltas(hitsHandle); // {}
var hits3 = __tracer.hitCountDeltas(hitsHandle); // {}
var hits4 = __tracer.hitCountDeltas(hitsHandle); // { 'func-id-2' : 1 }
var hits5 = __tracer.hitCountDeltas(hitsHandle); // {}
// ...
</pre>

<h3 id="section-api">API Reference</h3>

<p>I apologize for inconsistencies. The only consumer of this API until recently was my own project, <a href="https://github.com/adobe-research/theseus">Theseus</a>.

<h4>Fondue's API</h4>

<table class="api outlined">
	<tr>
		<th>
			<tt class="code">require('fondue').instrument(src, options)</tt><br />
			<tt class="code">fondue.instrument(src, options)</tt>
		</th>
		<td>
			<p>Use the first version in Node.js (after <tt>npm install fondue</tt>) and the second version if you include <tt><a href="https://github.com/adobe-research/fondue/blob/master/fondue.browser.js">fondue.browser.js</a></tt> on a web page, which creates a global <tt>fondue</tt> object.

			<p>These functions take JavaScript source code in the <tt>src</tt> argument and return a string containing an instrumented version of that source code.

			<p><tt>options</tt> is an object (or null) with any the following keys:

			<table class="outlined">
				<tr>
					<th>Key</th>
					<th>Default value</th>
					<th>Description</th>
				</tr>
				<tr>
					<th><tt>path</tt></th>
					<th><tt>"&lt;anonymous&gt;"</tt></th>
					<td>The path of the source code being instrumented. It doesn't load the code from that page, only embeds that information as meta-data, so it can be whatever you want.</td>
				</tr>
				<tr>
					<th><tt>include_prefix</tt></th>
					<th><tt>true</tt></th>
					<td>Whether to include the source code underlying the <tt>__tracer</tt> object. It's okay for this code to be included multiple times, so always leaving it on is okay. It's just kind of big.</td>
				</tr>
				<tr>
					<th><tt>tracer_name</tt></th>
					<th><tt>__tracer</tt></th>
					<td>The name to use for the global object containing the trace information.</td>
				</tr>
				<tr>
					<th><tt>nodejs</tt></th>
					<th><tt>false</tt></th>
					<td>If <tt>src</tt> will be executed in Node.js (not the browser), then set this to true to enable some Node.js-specific functionality.</td>
				</tr>
				<tr>
					<th><tt>maxInvocationsPerTick</tt></th>
					<th><tt>4096</tt></th>
					<td>When more than this many trace points (nodes) are executed in a single tick of the JavaScript VM, fondue will stop storing trace information until the next tick. This prevents intense calculation from filling all your RAM.</td>
				</tr>
				<tr>
					<th><tt>throw_parse_errors</tt></th>
					<th><tt>false</tt></th>
					<td>Whether to throw parse errors as exceptions, or just print them with <tt>console.error</tt> and attempt to continue. By default, when there's a parse error, the code is just passed through without instrumentation.</td>
				</tr>
			</table>
		</td>
	</tr>
</table>

<h4><tt>__tracer</tt> API</h4>

<p>Fondue-instrumented code creates a global <tt>__tracer</tt> object that you can also access to get information about that code's execution.

<table class="api outlined">
	<tr>
		<th><tt class="code">__tracer.version()</tt></th>
		<td>Returns a string like <tt>"0.6.1"</tt> with the version of Fondue being used.</td>
	</tr>
	<tr>
		<th>
			<tt class="code">handle = __tracer.trackNodes()</tt><br />
			<tt class="code">nodes = __tracer.newNodes(handle)</tt>
		</th>
		<td>
			<p>Get all known trace points in the program (functions, function call sites, etc).

			<table class="outlined">
				<tr>
					<th><tt>id</tt></th>
					<td>Unique string identifier for this node. It currently consists of the path, start, and end locations in the file, separated by dashes, but please don't rely on that.</td>
				</tr>
				<tr>
					<th><tt>type</tt></th>
					<td>The node type as a string. Currently one of <tt>"toplevel"</tt>, <tt>"function"</tt>, or <tt>"callsite"</tt>.</td>
				</tr>
				<tr>
					<th><tt>name</tt></th>
					<td>A pretty name for the node. For named functions, it's the name. ForÂ anonymous functions, fondue tries to make something appropriate like <tt>"(timer handler (200ms))"</tt>.</td>
				</tr>
				<tr>
					<th><tt>path</tt></th>
					<td>Path of the file the node is in, or <tt>"&lt;anonymous&gt;"</tt>.</td>
				</tr>
				<tr>
					<th><tt>start</tt></th>
					<td>Start location in the file, like <tt class="code">{"line": 1, "column": 0}</tt>.</td>
				</tr>
				<tr>
					<th><tt>end</tt></th>
					<td>End location in the file, like <tt class="code">{"line": 7, "column": 1}</tt>.</td>
				</tr>
				<tr>
					<th><tt>params</tt></th>
					<td>
						<p>An array of the function's arguments (present only if <tt>type</tt> is <tt>function</tt>).

						<table class="outlined">
							<tr>
								<th><tt>name</tt></th>
								<td>Name of the argument</td>
							</tr>
							<tr>
								<th><tt>start</tt></th>
								<td>Start location in the file, like <tt class="code">{"line": 1, "column": 0}</tt>.</td>
							</tr>
							<tr>
								<th><tt>end</tt></th>
								<td>End location in the file, like <tt class="code">{"line": 7, "column": 1}</tt>.</td>
							</tr>
						</table>
					</td>
				</tr>
			</table>
		</td>
	</tr>
	<tr>
		<th>
			<tt class="code">handle = __tracer.trackHits()</tt><br />
			<tt class="code">hits = __tracer.hitCountDeltas(handle)</tt>
		</th>
		<td>
			<p>Get a map from node id to the number of times the node was executed since the last call to <tt>hitCountDeltas</tt> with the given <tt>handle</tt>. Only the ids of functions that actually executed will be present. So, if no code has been executed, <tt>hitCountDeltas</tt> will return an empty object.

			<p>Example return value of <tt>hitCountDeltas</tt>: <tt class="code">{ 'func-id-1' : 1, 'func-id-2' : 3 }</tt>.
		</td>
	</tr>
	<tr>
		<th>
			<tt class="code">handle = __tracer.trackExceptions()</tt><br />
			<tt class="code">hits = __tracer.newExceptions(handle)</tt>
		</th>
		<td>
			<p>Like <tt>trackHits</tt> and <tt>hitCountDeltas</tt>, except it only includes counts for nodes that threw an exception. The return value is also slightly different.

			<p>Example return value of <tt>newExceptions</tt>: <tt class="code">{ counts: { 'func-id-1' : 1, 'func-id-2' : 3 }}</tt>.
		</td>
	</tr>
	<tr>
		<th>
			<tt class="code">handle = __tracer.trackLogs(query)</tt><br />
			<tt class="code">invocations = __tracer.logDelta(handle, maxResults)</tt>
		</th>
		<td>
			<p><tt>invocations</tt> will be a chronological array of invocations that match the given query. For example, if your query matches one function, then the results will be a list of all the times that function was called, including the values of the arguments. If your query matches multiple functions, you'll get a list of the times that either function was called.

			<p><tt>query</tt> is an object describing which invocations you want to be returned. You will get a union of all matched invocations. <tt>query</tt> accepts the following keys:

			<table class="outlined">
				<tr>
					<th><tt>ids</tt></th>
					<td><strong>(optional)</strong> An array of node IDs that you want the invocations of. These are strings that you might get from <tt>node.id</tt> on a node you get from <tt>trackNodes</tt>.</td>
				</tr>
				<tr>
					<th><tt>logs</tt></th>
					<td><strong>(optional)</strong> A boolean, <tt>true</tt> if you want all invocations of the special <tt>[log]</tt> function that represents <tt>console.log</tt>. With this you can recreate the terminal output of a program.</td>
				</tr>
				<tr>
					<th><tt>eventNames</tt></th>
					<td><strong>(optional)</strong> An array of strings, each one the name of an event whose invocations to include. See <tt>trackEpochs</tt> for a description of what an event is.</td>
				</tr>
				<tr>
					<th><tt>exceptions</tt></th>
					<td><strong>(optional)</strong> A boolean, <tt>true</tt> if all trace points that threw an exception should be included.</td>
				</tr>
			</table>

			<p>Each object in the <tt>invocations</tt> array has the following keys:

			<table class="outlined">
				<tr>
					<th><tt>timestamp</tt></th>
					<td>The result of calling <tt>(new Date).getTime()</tt> at the time the node was invoked.</td>
				</tr>
				<tr>
					<th><tt>tick</tt></th>
					<td>A number that goes up by one every time a trace point is reached. Primarily for use internally to enforce <tt>maxInvocationsPerTick</tt>. This shouldn't have been called "tick" because that word usually refers to one run of the JavaScript event loop, and that's how it's used everywhere else in this document.</td>
				</tr>
				<tr>
					<th><tt>invocationId</tt></th>
					<td>A unique string identifier for this invocation.</td>
				</tr>
				<tr>
					<th><tt>parents</tt></th>
					<td>
						<p>An array of objects representing synchronous or asynchronous parents in the call graph. Only parent invocations that are also matched by the query will be included. This is so that you can render these nodes as a graph without edges that go nowhere. Each parent object has the following keys:

						<table class="outlined">
							<tr>
								<th><tt>invocationId</tt></th>
								<td>The <tt>invocationId</tt> of the parent invocation</td>
							</tr>
							<tr>
								<th><tt>type</tt></th>
								<td>
									<p>A string, either <tt>"call"</tt> (synchronous call chain) or <tt>"async"</tt> (asynchronous call chain).

									<p>An example of an <tt>"async"</tt> parent would be if you had this code:
									<pre class="code">function foo() {
	setTimeout(function bar() { /* ... */ });
}</pre>
									<p>Then invocations of <tt>foo()</tt> would be <tt>"async"</tt> parents of invocations to <tt>bar()</tt>. <tt>foo()</tt> doesn't call <tt>bar()</tt> directly, but <tt>bar()</tt>'s closure gets created inside of <tt>foo()</tt>, so <tt>foo()</tt> is considered a parent.
								</td>
							</tr>
						</table>
					</td>
				</tr>
				<tr>
					<th><tt>topLevelInvocationId</tt></th>
					<td>Identifier of the invocation at the top of the stack when this invocation occurred. For example, when <tt>setTimeout(function foo() { }, 100)</tt> fires, function <tt>foo</tt> will be at the top of the stack, and every function that's called synchronously by <tt>foo</tt> will have the ID of that invocation of <tt>foo</tt> as its <tt>topLevelInvocationId</tt>.</td>
				</tr>
				<tr>
					<th><tt>nodeId</tt></th>
					<td>Identifier of the node that was invoked (e.g. <tt>node.id</tt> of a node you got from <tt>trackNodes</tt>).</td>
				</tr>
				<tr>
					<th><tt>arguments</tt></th>
					<td>
						<p>This key is only present if the node's type was <tt>function</tt>. It's an array of objects representing each argument value that was passed to the function, in order. Each object has these keys:

						<table class="outlined">
							<tr>
								<th><tt>name</tt></th>
								<td><strong>(optional)</strong> The name of the argument according to the function definition. If you define <tt>function foo(a) { }</tt> and call it like <tt>foo(1, 2)</tt>, then the object in this array for the first argument will have <tt>"a"</tt> as the <tt>name</tt> for the first argument, and no <tt>name</tt> for the second argument.</td>
							</tr>
							<tr>
								<th><tt>value</tt></th>
								<td>
									<p>An object describing the value that was passed into the function. This isn't the object itself, but a JSON-friendly description and summary. Each object looks like this:

									<table class="outlined">
										<tr>
											<th><tt>type</tt></th>
											<td>
												<p>A string, the result of <tt class="code">typeof object</tt> with some exceptions:
												<ul>
												<li><tt>typeof document.all</tt> (and possibly other objects) claims to be <tt>undefined</tt>, but Fondue calls it an <tt>object</tt>.
												<li>The <tt>type</tt> of <tt class="code">null</tt> is <tt>"null"</tt>.
												</ul>
											</td>
										</tr>
										<tr>
											<th><tt>value</tt></th>
											<td><strong>(optional)</strong> If it's a simple, JSONifiable value like a number, boolean, or string, then <tt>value</tt> will simply be that number or string.</td>
										</tr>
										<tr>
											<th><tt>preview</tt></th>
											<td><strong>(optional)</strong> If present, this is a short string summary of the object. For example, for an array it might be <tt>"[Array:6]"</tt>.</td>
										</tr>
										<tr>
											<th><tt>ownProperties</tt></th>
											<td>
												<p><strong>(optional)</strong> For objects, this is an object whose keys are all the keys from the original object for which <tt>hasOwnProperty</tt> is true. The values are objects just like this one, with <tt>type</tt>, <tt>value</tt>, <tt>preview</tt>, <tt>ownProperties</tt>, and <tt>truncated</tt> keys.

												<p>There's currently no way to see an object's prototype.

												<p>Fondue will not let this structure recurse indefinitely. See <tt>truncated</tt>.
											</td>
										</tr>
										<tr>
											<th><tt>truncated</tt></th>
											<td>
												<p><strong>(optional)</strong> Fondue will not let <tt>ownProperties</tt> recurse indefinitely. Once it detects that its representation of this object has reached a certain size, it stores only truncated versions of each object it comes across. If this key is present, then this object didn't make the cut.

												<p>The value of <tt>truncated</tt> is an object with these keys:

												<table class="outlined">
													<tr>
														<th><tt>length</tt></th>
														<td><strong>(optional)</strong> If present, this is an object like <tt class="code">{ amount: 4 }</tt>, containing how many items from the end of the <tt>Buffer</tt> were omitted from the representation.</td>
													</tr>
													<tr>
														<th><tt>keys</tt></th>
														<td><strong>(optional)</strong> If present, this is an object like <tt class="code">{ amount: 4 }</tt>, containing how many keys from the object were omitted from the representation. Missing array values are also counted here.</td>
													</tr>
												</table>
											</td>
										</tr>
									</table>
								</td>
							</tr>
						</table>
					</td>
				</tr>
			</table>
		</td>
	</tr>
</table>

<p>There are more functions, which I will document soon. <a href="mailto:tom@alltom.com">E-mail me</a> to bug me about it.

<h2 id="section-fancy">Getting fancy (tracing whole programs, whole web sites, etc)</h2>

<table class="outlined">
	<tr>
		<th>Instrumented code runs in</th>
		<th>Visualization code runs in</th>
		<th>Strategy</th>
	</tr>
	<tr>
		<td>Browser</td>
		<td>Browser</td>
		<td><strong>Pre-processing.</strong> Pre-process the code with <tt>bin/fondue</tt> (as in the example above) or with <tt>require('fondue').instrument(src, options)</tt> in Node.js, then execute the output on a web page with a <tt>&lt;script&gt;</tt> tag. That creates a global <tt>__tracer</tt> on which you can call the above methods directly from the same page. The "script that inspects itself" example on this page works this way.</td>
	</tr>
	<tr>
		<td>Node.js</td>
		<td>Node.js</td>
		<td><strong>Pre-processing.</strong> Same as with the Browser/Browser case above. <tt>eval()</tt> code that has been run through the <tt>instrument()</tt> function and check the global <tt>__tracer</tt> object.</td>
	</tr>
	<tr>
		<td>Browser</td>
		<td>Browser</td>
		<td><strong>Dynamic instrumentation.</strong> Process the code with <tt>fondue.instrument(src, options)</tt> on a web page itself after including <tt><a href="https://github.com/adobe-research/fondue/blob/master/fondue.browser.js">fondue.browser.js</a></tt>, the browser build of Fondue. Execute the output with <tt>eval(src)</tt>. That also creates a global <tt>__tracer</tt> on which you can call the above methods directly. <a href="playground.html">The Fondue playground</a> works this way.</td>
	</tr>
	<tr>
		<td>Browser</td>
		<td>Browser</td>
		<td><strong>Node.js middleware.</strong> Drop <a href="https://github.com/alltom/fondue-middleware">fondue-middleware</a> into a Node.js server. When it detects that you're serving a JavaScript file, or an HTML file with embedded <tt>&lt;script&gt;</tt> tags, it will automatically process the scripts with Fondue. When that code executes on the web page, that creates a global <tt>__tracer</tt> object on which you can call the above methods directly.</td>
	</tr>
	<tr>
		<td>Node.js</td>
		<td>Browser</td>
		<td><strong>Remote Node.js instrumentation.</strong> Run the Node.js app with <tt>node-theseus</tt> instead of <tt>node</tt> (first, <tt>npm install -g node-theseus</tt>), which starts a WebSocket server that exposes the <tt>__tracer</tt> object via a simple RPC API. <a href="https://github.com/alltom/node-theseus-d3">Here's an example project that displays information about a running Node.js process with d3</a>.</td>
	</tr>
</table>
